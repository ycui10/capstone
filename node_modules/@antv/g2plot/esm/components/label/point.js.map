{"version":3,"file":"point.js","sourceRoot":"","sources":["../../../src/components/label/point.ts"],"names":[],"mappings":"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","sourcesContent":["import { get, map, isArray, last, each } from '@antv/util';\nimport { Element, MappingDatum, _ORIGIN } from '../../dependents';\nimport BaseLabel, { registerLabelComponent } from '../../components/label/base';\nimport { TextStyle, Label } from '../../interface/config';\nimport { IShape, Geometry } from '../../dependents';\nimport { isBBoxIntersect } from '../../util/common';\n\n/**\n * 说明:\n * 适用于展示面积图和折线图上数据点的label\n * */\n\nexport default class PointLabel<L extends Label = Label> extends BaseLabel<L> {\n  protected getDefaultOptions() {\n    const { theme } = this.layer;\n    const { label = {} } = theme;\n    return {\n      offsetX: 0,\n      offsetY: 0,\n      ...label,\n    };\n  }\n\n  protected getLabelOffset() {\n    return this.getLabelOffsetByDimAndFactor('y', -1);\n  }\n\n  protected getLabelItemAttrs(element: Element, index: number): TextStyle[] {\n    const { style, formatter } = this.options;\n    const mappingData: MappingDatum[] = get(element, 'model.mappingData', []);\n\n    return map(mappingData, (datum, datumIndex) => {\n      const value = this.getValue(datum);\n      return {\n        ...this.getPosition(datum),\n        text: formatter\n          ? formatter(\n              value,\n              {\n                [_ORIGIN]: datum._origin,\n                mappingDatum: datum,\n                mappingDatumIndex: datumIndex,\n                element,\n                elementIndex: index,\n              },\n              index\n            )\n          : value,\n        textAlign: 'center',\n        textBaseline: 'middle',\n        ...style,\n      };\n    });\n  }\n\n  protected getValue(datum: MappingDatum): number | undefined | null {\n    return get(datum._origin, this.layer.options.yField);\n  }\n\n  protected getPosition(datum: MappingDatum): { x: number; y: number } {\n    const pos = {\n      x: isArray(datum.x) ? last(datum.x) : datum.x,\n      y: isArray(datum.y) ? last(datum.y) : datum.y,\n    };\n    return pos;\n  }\n\n  protected layoutLabels(geometry: Geometry, labels: IShape[]): void {\n    if (!this.options.adjustPosition) {\n      return;\n    }\n    let overlap = this.isOverlapped(labels);\n    // 规则1：先横向，优先显示横向上变化趋势大的label\n    if (overlap) {\n      const tolerance = this.getGlobalTolerance(labels);\n      each(labels, (label, index) => {\n        if (index > 1) {\n          this.labelResamplingByChange(label, labels, index, tolerance);\n        }\n      });\n    }\n    overlap = this.isOverlapped(labels);\n    // 规则2： 后纵向，优先保留纵向最高点label\n    if (overlap) {\n      each(labels, (label, index) => {\n        if (label.get('visible')) {\n          this.clearOverlapping(label, labels, index);\n        }\n      });\n    }\n  }\n\n  protected adjustLabel() {\n    return;\n  }\n\n  /** 根据变化进行抽样，保留变化较大的点，类似于点简化算法 */\n  private labelResamplingByChange(label: IShape, labels: IShape[], index: number, tolerance: number) {\n    const previous = this.findPrevious(index, labels);\n    const currentCenter = this.getCenter(label);\n    const previousCenter = this.getCenter(previous);\n    const distX = previousCenter.x - currentCenter.x;\n    const distY = previousCenter.y - currentCenter.y;\n    const dist = Math.sqrt(distX * distX + distY * distY);\n    if (dist < tolerance) {\n      label.set('visible', false);\n    }\n  }\n\n  private clearOverlapping(label: IShape, labels: IShape[], index: number) {\n    // 找到所有与当前点overlap的node\n    const overlapped = [];\n    for (let i = 0; i < labels.length; i++) {\n      const current = labels[i];\n      if (i !== index && current.get('visible')) {\n        const isOverlap = isBBoxIntersect(label.getBBox(), current.getBBox());\n        if (isOverlap) {\n          overlapped.push(current);\n        }\n      }\n    }\n    // 对overapped label进行处理\n    if (overlapped.length > 0) {\n      overlapped.push(label);\n      overlapped.sort((a, b) => {\n        return b.minY - a.minY;\n      });\n      // 隐藏除最高点以外的label\n      each(overlapped, (label: IShape, index: number) => {\n        if (index > 0) {\n          label.set('visible', false);\n        }\n      });\n    }\n  }\n\n  /** 检测一组label中是否存在重叠 **/\n  private isOverlapped(labels: IShape[]) {\n    for (let i = 0; i < labels.length; i++) {\n      if (labels[i].get('visible')) {\n        const labelABBox = labels[i].getBBox();\n        for (let j = 0; j < labels.length; j++) {\n          if (j !== i && labels[j].get('visible')) {\n            const labelBBBox = labels[j].getBBox();\n            const intersection = isBBoxIntersect(labelABBox, labelBBBox);\n            if (intersection) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  private getGlobalTolerance(labels: IShape[]) {\n    const labelsClone = labels.slice();\n    labelsClone.sort((a, b) => {\n      return b.getBBox().width - a.getBBox().width;\n    });\n    return Math.round(labelsClone[0].getBBox().width);\n  }\n\n  private findPrevious(index: number, labels: IShape[]) {\n    for (let i = index - 1; i > 0; i--) {\n      if (labels[i].get('visible')) {\n        return labels[i];\n      }\n    }\n  }\n\n  private getCenter(label: IShape) {\n    const { minX, maxX, minY, maxY } = label.getBBox();\n    return { x: minX + (maxX - minX) / 2, y: minY + (maxY - minY) / 2 };\n  }\n}\n\nregisterLabelComponent('point', PointLabel);\n"]}