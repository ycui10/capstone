import { __assign, __extends } from "tslib";
import { get, map, isArray, last, each } from '@antv/util';
import { _ORIGIN } from '../../dependents';
import BaseLabel, { registerLabelComponent } from '../../components/label/base';
import { isBBoxIntersect } from '../../util/common';
/**
 * 说明:
 * 适用于展示面积图和折线图上数据点的label
 * */
var PointLabel = /** @class */ (function (_super) {
    __extends(PointLabel, _super);
    function PointLabel() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PointLabel.prototype.getDefaultOptions = function () {
        var theme = this.layer.theme;
        var _a = theme.label, label = _a === void 0 ? {} : _a;
        return __assign({ offsetX: 0, offsetY: 0 }, label);
    };
    PointLabel.prototype.getLabelOffset = function () {
        return this.getLabelOffsetByDimAndFactor('y', -1);
    };
    PointLabel.prototype.getLabelItemAttrs = function (element, index) {
        var _this = this;
        var _a = this.options, style = _a.style, formatter = _a.formatter;
        var mappingData = get(element, 'model.mappingData', []);
        return map(mappingData, function (datum, datumIndex) {
            var _a;
            var value = _this.getValue(datum);
            return __assign(__assign(__assign({}, _this.getPosition(datum)), { text: formatter
                    ? formatter(value, (_a = {},
                        _a[_ORIGIN] = datum._origin,
                        _a.mappingDatum = datum,
                        _a.mappingDatumIndex = datumIndex,
                        _a.element = element,
                        _a.elementIndex = index,
                        _a), index)
                    : value, textAlign: 'center', textBaseline: 'middle' }), style);
        });
    };
    PointLabel.prototype.getValue = function (datum) {
        return get(datum._origin, this.layer.options.yField);
    };
    PointLabel.prototype.getPosition = function (datum) {
        var pos = {
            x: isArray(datum.x) ? last(datum.x) : datum.x,
            y: isArray(datum.y) ? last(datum.y) : datum.y,
        };
        return pos;
    };
    PointLabel.prototype.layoutLabels = function (geometry, labels) {
        var _this = this;
        if (!this.options.adjustPosition) {
            return;
        }
        var overlap = this.isOverlapped(labels);
        // 规则1：先横向，优先显示横向上变化趋势大的label
        if (overlap) {
            var tolerance_1 = this.getGlobalTolerance(labels);
            each(labels, function (label, index) {
                if (index > 1) {
                    _this.labelResamplingByChange(label, labels, index, tolerance_1);
                }
            });
        }
        overlap = this.isOverlapped(labels);
        // 规则2： 后纵向，优先保留纵向最高点label
        if (overlap) {
            each(labels, function (label, index) {
                if (label.get('visible')) {
                    _this.clearOverlapping(label, labels, index);
                }
            });
        }
    };
    PointLabel.prototype.adjustLabel = function () {
        return;
    };
    /** 根据变化进行抽样，保留变化较大的点，类似于点简化算法 */
    PointLabel.prototype.labelResamplingByChange = function (label, labels, index, tolerance) {
        var previous = this.findPrevious(index, labels);
        var currentCenter = this.getCenter(label);
        var previousCenter = this.getCenter(previous);
        var distX = previousCenter.x - currentCenter.x;
        var distY = previousCenter.y - currentCenter.y;
        var dist = Math.sqrt(distX * distX + distY * distY);
        if (dist < tolerance) {
            label.set('visible', false);
        }
    };
    PointLabel.prototype.clearOverlapping = function (label, labels, index) {
        // 找到所有与当前点overlap的node
        var overlapped = [];
        for (var i = 0; i < labels.length; i++) {
            var current = labels[i];
            if (i !== index && current.get('visible')) {
                var isOverlap = isBBoxIntersect(label.getBBox(), current.getBBox());
                if (isOverlap) {
                    overlapped.push(current);
                }
            }
        }
        // 对overapped label进行处理
        if (overlapped.length > 0) {
            overlapped.push(label);
            overlapped.sort(function (a, b) {
                return b.minY - a.minY;
            });
            // 隐藏除最高点以外的label
            each(overlapped, function (label, index) {
                if (index > 0) {
                    label.set('visible', false);
                }
            });
        }
    };
    /** 检测一组label中是否存在重叠 **/
    PointLabel.prototype.isOverlapped = function (labels) {
        for (var i = 0; i < labels.length; i++) {
            if (labels[i].get('visible')) {
                var labelABBox = labels[i].getBBox();
                for (var j = 0; j < labels.length; j++) {
                    if (j !== i && labels[j].get('visible')) {
                        var labelBBBox = labels[j].getBBox();
                        var intersection = isBBoxIntersect(labelABBox, labelBBBox);
                        if (intersection) {
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    };
    PointLabel.prototype.getGlobalTolerance = function (labels) {
        var labelsClone = labels.slice();
        labelsClone.sort(function (a, b) {
            return b.getBBox().width - a.getBBox().width;
        });
        return Math.round(labelsClone[0].getBBox().width);
    };
    PointLabel.prototype.findPrevious = function (index, labels) {
        for (var i = index - 1; i > 0; i--) {
            if (labels[i].get('visible')) {
                return labels[i];
            }
        }
    };
    PointLabel.prototype.getCenter = function (label) {
        var _a = label.getBBox(), minX = _a.minX, maxX = _a.maxX, minY = _a.minY, maxY = _a.maxY;
        return { x: minX + (maxX - minX) / 2, y: minY + (maxY - minY) / 2 };
    };
    return PointLabel;
}(BaseLabel));
export default PointLabel;
registerLabelComponent('point', PointLabel);
//# sourceMappingURL=point.js.map