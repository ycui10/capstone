import { isObject, each, get } from '@antv/util';
import { polarToCartesian } from '../../../../util/graphics';
/** label text和line距离 4px */
var MARGIN = 4;
function antiCollision(labelShapes, labels, labelHeight, plotRange, center, radius, isRight) {
    // sorted by y, mutable
    labels.sort(function (a, b) { return a.y - b.y; });
    // adjust y position of labels to avoid overlapping
    var start = plotRange.start;
    var end = plotRange.end;
    var startY = Math.min(start.y, end.y);
    var endY = Math.max(start.y, end.y);
    var i;
    var boxes = labels.map(function (label) {
        return {
            content: label.content,
            size: labelHeight,
            pos: label.y,
            targets: [label.y],
        };
    });
    var maxPos = Math.max.apply(Math, boxes.map(function (b) { return b.pos; }));
    var minPos = Math.min.apply(Math, boxes.map(function (b) { return b.pos; }));
    /**
     * when in right, shift from up to down
     */
    if (isRight) {
        var minY = Math.min(minPos, endY - (boxes.length - 1) * labelHeight);
        var maxY = Math.max(minY + boxes.length * labelHeight, maxPos + labelHeight);
        var overlapping = true;
        while (overlapping) {
            // detect overlapping and join boxes
            overlapping = false;
            i = boxes.length;
            while (i--) {
                if (i > 0) {
                    var previousBox = boxes[i - 1];
                    var box = boxes[i];
                    // overlap
                    if (previousBox.pos + previousBox.size > box.pos) {
                        if (box.pos + i * labelHeight < maxY) {
                            // join boxes
                            previousBox.size += box.size;
                            previousBox.targets = previousBox.targets.concat(box.targets);
                            // removing box
                            boxes.splice(i, 1);
                        }
                        else {
                            previousBox.pos = box.pos - previousBox.size;
                        }
                        overlapping = true;
                    }
                }
            }
        }
    }
    else {
        var maxY = Math.max(startY + (boxes.length - 1) * labelHeight, maxPos);
        var minY = Math.min(minPos, maxY - (boxes.length - 1) * labelHeight);
        var overlapping = true;
        while (overlapping) {
            // detect overlapping and join boxes
            overlapping = false;
            i = boxes.length;
            while (i--) {
                if (i > 0) {
                    var previousBox = boxes[i - 1];
                    var box = boxes[i];
                    // overlap
                    if (previousBox.pos + previousBox.size > box.pos) {
                        if (previousBox.pos - minY > i * labelHeight) {
                            previousBox.pos -= previousBox.size;
                        }
                        else {
                            // join boxes
                            previousBox.size += box.size;
                            previousBox.targets = previousBox.targets.concat(box.targets);
                            // removing box
                            boxes.splice(i, 1);
                        }
                        overlapping = true;
                    }
                }
            }
        }
    }
    // step 4: normalize y and adjust x
    i = 0;
    boxes.forEach(function (b) {
        var posInCompositeBox = b.pos;
        b.targets.forEach(function () {
            labels[i].y = posInCompositeBox;
            posInCompositeBox += labelHeight;
            i++;
        });
    });
    var labelsMap = {};
    for (var _i = 0, labelShapes_1 = labelShapes; _i < labelShapes_1.length; _i++) {
        var labelShape = labelShapes_1[_i];
        labelsMap[labelShape.get('id')] = labelShape;
    }
    // (x - cx)^2 + (y - cy)^2 = totalR^2
    var totalR = (Math.max.apply(Math, labels.map(function (l) { return l.y; })) - Math.min.apply(Math, labels.map(function (l) { return l.y; }))) / 2;
    totalR = Math.max(totalR, radius);
    labels.forEach(function (label) {
        var labelShape = labelsMap[label.id];
        // because group could not effect text-shape, should set text-shape position manually
        var textShape = labelShape.find(function (child) { return child.get('type') === 'text'; });
        // textShape 发生过调整
        if (textShape && textShape.attr('y') !== label.y) {
            var rPow2 = totalR * totalR;
            var dyPow2 = Math.pow(Math.abs(label.y - center.y), 2);
            if (rPow2 < dyPow2) {
                label.x = center.x;
            }
            else {
                var dx = Math.sqrt(rPow2 - dyPow2);
                if (!isRight) {
                    // left
                    label.x = center.x - dx;
                }
                else {
                    // right
                    label.x = center.x + dx;
                }
            }
        }
        // adjust labelShape
        labelShape.attr('x', label.x);
        labelShape.attr('y', label.y);
        // @ts-ignore
        if (textShape) {
            textShape.attr('y', label.y);
            textShape.attr('x', label.x);
        }
    });
}
export function pieOuterLabelLayout(items, labels, shapes, region) {
    var offset = items[0] ? items[0].offset : 0;
    var coordinate = labels[0].get('coordinate');
    var radius = coordinate.getRadius();
    var center = coordinate.getCenter();
    if (offset > 0) {
        // note labelHeight 可以控制 label 的行高
        var lineHeight_1 = get(items[0], 'labelHeight', 14);
        var totalR_1 = radius + offset;
        var totalHeight_1 = totalR_1 * 2 + lineHeight_1 * 2;
        var plotRange_1 = {
            start: coordinate.start,
            end: coordinate.end,
        };
        // step 1: separate labels
        var halves_1 = [
            [],
            [],
        ];
        items.forEach(function (labelItem) {
            if (!labelItem) {
                return;
            }
            if (labelItem.x < center.x) {
                // left
                halves_1[0].push(labelItem);
            }
            else {
                // right or center will be put on the right side
                halves_1[1].push(labelItem);
            }
        });
        halves_1.forEach(function (half, index) {
            // step 2: reduce labels
            var maxLabelsCountForOneSide = totalHeight_1 / lineHeight_1;
            if (half.length > maxLabelsCountForOneSide) {
                half.sort(function (a, b) {
                    // sort by percentage DESC
                    // fixme-xinming 目前还获取不到，需要使用 scale 去获取 percent
                    return b['data.percent'] - a['data.percent'];
                });
                var hidden = half.splice(maxLabelsCountForOneSide, half.length - maxLabelsCountForOneSide + 1);
                hidden.forEach(function (l) {
                    var idx = labels.findIndex(function (item) { return item.get('id') === l.id; });
                    if (labels[idx]) {
                        labels[idx].remove(true);
                        // 同时移除
                        labels.splice(idx, 1);
                    }
                });
            }
            antiCollision(labels, half, lineHeight_1, plotRange_1, center, totalR_1, index === 1);
        });
    }
    // 配置 labelLine
    each(items, function (item) {
        if (item && item.labelLine) {
            var angle = item.angle;
            // 贴近圆周
            var startPoint = polarToCartesian(center.x, center.y, radius, angle);
            var itemX = item.x + get(item, 'offsetX', 0) * (Math.cos(angle) > 0 ? 1 : -1);
            var itemY = item.y + get(item, 'offsetY', 0) * (Math.sin(angle) > 0 ? 1 : -1);
            var endPoint = {
                x: itemX - Math.cos(angle) * MARGIN,
                y: itemY - Math.sin(angle) * MARGIN,
            };
            var smoothConnector = item.labelLine.smooth;
            var path = [];
            var dx = endPoint.x - center.x;
            var dy = endPoint.y - center.y;
            var endAngle = Math.atan(dy / dx);
            // 第三象限 & 第四象限
            if (dx < 0) {
                endAngle += Math.PI;
            }
            // 默认 smooth, undefined 也为 smooth
            if (smoothConnector === false) {
                if (!isObject(item.labelLine)) {
                    // labelLine: true
                    item.labelLine = {};
                }
                // 表示弧线的方向，0 表示从起点到终点沿逆时针画弧, 1 表示顺时针
                var sweepFlag = 0;
                // 第一象限
                if ((angle < 0 && angle > -Math.PI / 2) || angle > Math.PI * 1.5) {
                    if (endPoint.y > startPoint.y) {
                        sweepFlag = 1;
                    }
                }
                // 第二象限
                if (angle >= 0 && angle < Math.PI / 2) {
                    if (endPoint.y > startPoint.y) {
                        sweepFlag = 1;
                    }
                }
                // 第三象限
                if (angle >= Math.PI / 2 && angle < Math.PI) {
                    if (startPoint.y > endPoint.y) {
                        sweepFlag = 1;
                    }
                }
                // 第四象限
                if (angle < -Math.PI / 2 || (angle >= Math.PI && angle < Math.PI * 1.5)) {
                    if (startPoint.y > endPoint.y) {
                        sweepFlag = 1;
                    }
                }
                var distance = offset / 2 > 4 ? 4 : Math.max(offset / 2 - 1, 0);
                var breakPoint = polarToCartesian(center.x, center.y, radius + distance, angle);
                // 圆弧的结束点
                var breakPoint3 = polarToCartesian(center.x, center.y, radius + offset / 2, endAngle);
                /**
                 * @example
                 * M 100 100 L100 90 A 50 50 0 0 0 150 50
                 * 移动至 (100, 100), 连接到 (100, 90), 以 (50, 50) 为圆心，绘制圆弧至 (150, 50);
                 * A 命令的第 4 个参数 large-arc-flag, 决定弧线是大于还是小于 180 度: 0 表示小角度弧，1 表示大角
                 * 第 5 个参数: 是否顺时针绘制
                 */
                // 默认小弧
                var largeArcFlag = 0;
                // step1: 移动至起点
                path.push("M " + startPoint.x + " " + startPoint.y);
                // step2: 连接拐点
                path.push("L " + breakPoint.x + " " + breakPoint.y);
                // step3: 绘制圆弧 至 结束点
                path.push("A " + center.x + " " + center.y + " 0 " + largeArcFlag + " " + sweepFlag + " " + breakPoint3.x + " " + breakPoint3.y);
                // step4: 连接结束点
                path.push("L " + endPoint.x + " " + endPoint.y);
            }
            else {
                var breakPoint = polarToCartesian(center.x, center.y, radius + (offset / 2 > 4 ? 4 : Math.max(offset / 2 - 1, 0)), angle);
                // G2 旧的拉线
                // path.push('Q', `${breakPoint.x}`, `${breakPoint.y}`, `${endPoint.x}`, `${endPoint.y}`);
                var xSign = startPoint.x < center.x ? 1 : -1;
                // step1: 连接结束点
                path.push("M " + endPoint.x + " " + endPoint.y);
                var slope1 = (startPoint.y - center.y) / (startPoint.x - center.x);
                var slope2 = (endPoint.y - center.y) / (endPoint.x - center.x);
                if (Math.abs(slope1 - slope2) > Math.pow(Math.E, -16)) {
                    // step2: 绘制 curve line (起点 & 结合点与圆心的斜率不等时, 由于存在误差, 使用近似处理)
                    path.push.apply(path, [
                        'C',
                        endPoint.x + xSign * 4,
                        endPoint.y,
                        2 * breakPoint.x - startPoint.x,
                        2 * breakPoint.y - startPoint.y,
                        startPoint.x,
                        startPoint.y,
                    ]);
                }
                // step3: 连接至起点
                path.push("L " + startPoint.x + " " + startPoint.y);
            }
            item.labelLine.path = path.join(' ');
        }
    });
}
//# sourceMappingURL=outer.js.map